{
    "sieve c++": {
        "prefix": "sieve",
        "body": [
          "// O(n) sieve up to n",
          "vector<int> sieve(int n) {",
          "    vector<int> lp(n, 0);",
          "    vector<int> primes;",
          "    for (int i = 2; i <= n; ++i) {",
          "        if (lp[i] == 0) {",
          "            lp[i] = i;",
          "            primes.push_back(i);",
          "        }",
          "        for (int j = 0; j < (int)primes.size() and primes[j] <= lp[i] and",
          "                        i * primes[j] <= n;",
          "             ++j)",
          "            lp[i * primes[j]] = primes[j];",
          "    }",
          "    return primes;",
          "}"
        ],
        "description": "sieve c++"
      },
      "miller rabin c++": {
        "prefix": "miller-rabin",
        "body": [
          "uint64_t binpower(uint64_t base, uint64_t e, uint64_t mod) {",
          "    uint64_t result = 1;",
          "    base %= mod;",
          "    while (e) {",
          "        if (e & 1) result = (__uint128_t)result * base % mod;",
          "        base = (__uint128_t)base * base % mod;",
          "        e >>= 1;",
          "    }",
          "    return result;",
          "}",
          "",
          "bool check_composite(uint64_t n, uint64_t a, uint64_t d, int s) {",
          "    uint64_t x = binpower(a, d, n);",
          "    if (x == 1 || x == n - 1) return false;",
          "    for (int r = 1; r < s; r++) {",
          "        x = (__uint128_t)x * x % n;",
          "        if (x == n - 1) return false;",
          "    }",
          "    return true;",
          "};",
          "",
          "bool MillerRabin(",
          "    uint64_t n,",
          "    int iter = 5) {  // returns true if n is probably prime, else returns false.",
          "    if (n < 4) return n == 2 || n == 3;",
          "",
          "    int s = 0;",
          "    uint64_t d = n - 1;",
          "    while ((d & 1) == 0) {",
          "        d >>= 1;",
          "        s++;",
          "    }",
          "",
          "    for (int i = 0; i < iter; i++) {",
          "        int a = 2 + rand() % (n - 3);",
          "        if (check_composite(n, a, d, s)) return false;",
          "    }",
          "    return true;",
          "}",
          "",
          "bool MillerRabin_deterministic(",
          "    uint64_t n) {  // returns true if n is prime, else returns false.",
          "    if (n < 2) return false;",
          "",
          "    int r = 0;",
          "    uint64_t d = n - 1;",
          "    while ((d & 1) == 0) {",
          "        d >>= 1;",
          "        r++;",
          "    }",
          "",
          "    for (int a : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37}) {",
          "        if (n == a) return true;",
          "        if (check_composite(n, a, d, r)) return false;",
          "    }",
          "    return true;",
          "}"
        ],
        "description": "miller rabin c++"
      }
}